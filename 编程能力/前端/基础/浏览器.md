# 1. 进程和线程

> 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

浏览器是多进程的。

> 整理资料：[浏览器的执行(1)-进程和线程](https://juejin.cn/post/6844904205916848135)

# 2. 从URL输入到页面展现到底发生什么？

0. 查找浏览器缓存
1. DNS 解析:将域名解析成 IP 地址（资料：[字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)）
2. TCP 连接：TCP 三次握手
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手

> 参考资料：[从URL输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)<br/>
页面优化：[简析link对加载速度的优化--从请求URL到页面加载](https://juejin.cn/post/6881899962754400263)<br/>

# 3. 浏览器渲染流程

* 浏览器的渲染过程大体如下：

1. HTML解析出DOM Tree
2. CSS解析出Style Rules
3. 将二者关联生成Render Tree
4. Layout 根据Render Tree计算每个节点的信息
5. Painting 根据计算好的信息绘制整个页面

* 可以在script标签上增加属性defer或者async，用于异步加载脚本文件。
**async下载完后马上执行，可能会阻塞html渲染进程；defer下载完后按顺序执行，不会阻塞html渲染进程。**

* 资源加载的影响
  * JS加载会阻塞渲染进程，阻塞css、img等其他文件加载。
  * CSS加载阻塞JS，阻塞页面渲染，不阻塞DOM解析和img加载
  * img和iframe不阻塞主进程

* 回流和重绘
回流成本高，涉及到页面的重新布局；布局完成后进行绘制，重绘在绘制阶段，不涉及到布局。[你真的了解回流和重绘吗](https://juejin.cn/post/6844903779700047885)

> 整理资料：[浏览器的执行(2)-浏览器渲染流程](https://juejin.cn/post/6844904205740687374)

# 4. JS运行机制 Event Loop

* 同步任务和异步任务：执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行。

* 宏任务(macrotask)和微任务(microtask)：宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）

> 参考资料：[浏览器的执行(3)-JS运行机制 Event Loop](https://juejin.cn/post/6844904206084603911)